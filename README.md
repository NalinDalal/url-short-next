# URL Shortner
The main goal is to build a url-shortneing service similar to [bit.ly](https://bitly.com/) or [tiny-url](https://tinyurl.com/).

URL shortening is a service that produces short aliases for long URLs, commonly referred to as short links. 
Upon clicking, these short links direct to the original URLs. The following illustration depicts how the process works:

<div class="relative clear-both "><div><div><div><div tabindex="0" style="outline:none"><div><div class=""><div id="widget-parent-" class=" font-nunito font-nunito"><div class="widget"><div class="text-center dark:bg-transparent"><div data-rmiz-wrap="visible"><div class="relative w-full"><object class="dark:bg-gray-D50" data="/api/collection/10370001/4941429335392256/page/6627189651144704/image/6727966763778048?page_type=collection_lesson&amp;get_optimised=true&amp;collection_token=undefined" aria-label="svg viewer" role="img" type="image/svg+xml" style="max-width: 100%; height: auto;"></object></div><button aria-label="Zoom image" data-rmiz-btn-open="true" type="button"></button></div></div><div class="mt-2.5 flex items-center justify-center"><span data-testid="caption-text" class="flex focus:outline-none rounded bg-gray-L50 text-black dark:bg-gray-D1400 dark:text-gray-D200 px-5 py-1 text-center font-normal ">How URL shortening service works</span></div></div></div></div></div></div></div></div></div></div>

# Requirement Designing
## Functional requirements
- *Short URL generation*: Our service should be able to generate a unique shorter alias of the given URL.
- *Redirection*: Given a short link, our system should be able to redirect the user to the original URL.
- *Custom short links*: Users should be able to generate custom short links for their URLs using our system.
- *Deletion*: Users should be able to delete a short link generated by our system, given the rights.
- *Update*: Users should be able to update the long URL associated with the short link, given the proper rights.
- *Expiry time*: There must be a default expiration time for the short links, but users should be able to set the expiration time based on their requirements.

Keep the limitation to 2 months so that the db can be indexed to previous url
else it will grow wxponentilly with time.

## Non-functional requirements
- *Availability*: Our system should be highly available, because even a fraction of the second downtime would result in URL redirection failures. Since our system’s domain is in URLs, we don’t have the leverage of downtime, and our design must have fault-tolerance conditions instilled in it.
- *Scalability*: Our system should be horizontally scalable with increasing demand.
- *Readability*: The short links generated by our system should be easily readable, distinguishable, and typeable.
- *Latency*: The system should perform at low latency to provide the user with a smooth experience.
- *Unpredictability*: From a security standpoint, the short links generated by our system should be highly unpredictable. This ensures that the next-in-line short URL is not serially produced, eliminating the possibility of someone guessing all the short URLs that our system has ever produced or will produce.
<div class="text-center dark:bg-transparent"><div data-rmiz-wrap="visible"><div class="relative w-full"><object class="dark:bg-gray-D50" data="/api/collection/10370001/4941429335392256/page/5146211836755968/image/6156843009441792?page_type=collection_lesson&amp;get_optimised=true&amp;collection_token=undefined" aria-label="svg viewer" role="img" type="image/svg+xml" style="max-width: 100%; height: auto;"></object></div><button aria-label="Zoom image" data-rmiz-btn-open="true" type="button"></button></div></div>

# Resource Estimation
let's say for instance:
- shortening:redirection request ratio is 1:100.
- 200 million req
- 1 req-> 500 byte of db storage
- 5 yr expiry time here
- 100 million users

# Storage
5 yr of time
200 million entries per month
total entries=200 million/month * 12 month * 5 = 12 billion
1 entry-> 500 byte: total= 12 billion * 500 byte=6 TB

# Query Estimation
200 million * 100 = 20 billion redirection
no od seconds in month-> 30.42 days * 24 hours * 60 minutes * 60 seconds=2628288 seconds

so in total-> 200 million/ 2628288 = 76 url/sec
with 1:100-> 7.6 k url/sec

# Bandwidth Estimation
total 76 url/sec-> data=304kbps
total shortening= 76*500 bytes * 8 bits= 304 Kbps
redirection: 7.6K URLs redirections/ second, the total outgoing data ->30.4Mbps per second: 7.6 K×500 Bytes×8 bits=30.4 Mbps

# Memory estimation
say 20 percent of redirection requests generate 80 percent of the traffic.
redirection req are 7.6k-> 0.66 billion/day
7.6k*3600*24, but only 20% are cached-> 7.6k*3600*24*0.2*500 bytes=66GB

# Server Estimation
Servers needed at peak load=( Number of requests/second )/ RPS of server
=100 million / 64,000
= 1562.5
≈ 1.6K

# Estimation Summary
| Type of operation     | Time estimates |
|------------------------|----------------|
| New URLs               | 76/s           |
| URL redirections       | 7.6 K/s        |
| Incoming data          | 304 Kbps       |
| Outgoing data          | 30.4 Mbps      |
| Storage for 5 years    | 6 TB           |
| Memory for cache       | 66 GB          |
| Servers                | 1600           |

## Building Blocks for High-Level Design

- **Databases**: Store mappings between long URLs and their corresponding short URLs.
- **Sequencer**: Generate unique IDs to start the short URL creation process.
- **Load Balancers**: Distribute incoming requests smoothly across servers.
- **Caches**: Store frequently accessed short URLs for faster access.
- **Rate Limiters**: Prevent abuse and overuse of the system.

### Additional Components

- **Servers**: Handle service requests and run application logic.
- **Base-58 Encoder**: Convert numeric IDs from the sequencer into readable alphanumeric short URLs.


# Design and Deployment of TinyURL
3 system api: 
- Shortening a URL
- Redirecting a short URL
- Deleting a short URL 

## Shortening the URL
```txt
shortURL(api_dev_key, original_url, custom_alias=None, expiry_date=None)
```

parameters:
| Parameter     | Description |
|---------------|-------------|
| `api_dev_key` | A registered user account’s unique identifier. Helps track user activity and control services accordingly. |
| `original_url` | The original long URL that needs to be shortened. |
| `custom_alias` | (Optional) A custom short URL key defined by the user. |
| `expiry_date` | (Optional) The expiration date for the shortened URL. |

## Redirecting a short URL
To redirect a short URL, the REST API’s definition will be:
```API
redirectURL(api_dev_key, url_key)
```

parameters:
| Parameter | Description |
|-----------|-------------|
|api_dev_key | The registered user account’s unique identifier. |
|url_key| The shortened URL against which we need to fetch the long URL from the database.|

## Deleting a short URL
```api
deleteURL(api_dev_key, url_key)
```
and the associated parameters will be:

| Parameter | Description |
|-----------|-------------|
|api_dev_key|The registered user account’s unique identifier.|
|url_key|The shortened URL against which we need to fetch the long URL from the database.|

A successful deletion returns a system message, `URL Removed`, conveying the successful URL removal from the system.

# Components

1. Databases: we will use NoSQL cause not really need to put lot of data: user
   details, mapped urls
2. Short-URL generator: sequencer for unique id, base58-encoder to enhance
   Readability of url
3. Load Balancer
4. Cache
5. Rate Limiter

# Workflow
1. Shortening: shorten the url provided; sends one copy back to the user and stores the record in the database for future use.
2. Redirection: check the storage units (caching system and database) for the required record. If found, the application server redirects the user to the associated long URL.
3. Deletion: either by the user or the expired links can also be redirected
4. Custom Shorten Link: maximum length= 11 alphanumeric digits.

# Encoder
Our sequencer generates a 64-bit ID in base-10, which can be converted to a base-64 short URL.
but the problem is that since it generates random, so the char like `0` and `O`
or `I` and `l` can be confused with each other.
hence use `base-58` instead of `base-64` a/f slashing out 6 chars->
`0`,`O`,`I`,`l`,

## Converting base-10 to base-58
Process: We keep dividing the base-10 number by 58, making note of the remainder at each step. We stop where there is no remainder left. 
Then we assign the character indexes to the remainders, starting from assigning the recent-most remainder to the left-most place and the oldest remainder to the right-most place.

## Converting base-58 to base-10
multiply each character index (value column from the table above) by the number of 58s that position holds, and add all the individual multiplication results.

# scope of the short URL generator
- The generated short URL should contain alphanumeric characters.

- None of the characters should look alike.

- The minimum default length of the generated short URL should be six characters.

Starting range: 1 to (2^64 -1)
Ending Point: depends on the maximum utilization of 64 bits
no of digit= total bits available/no of bit to represent one digit

Base 10: log(2)10->64/log(2)10=20
Base 58: log(2)58->64/log(2)58=11

## Sequencer Lifetime
- Total numbers available in the sequencer = 2^64−10^9 (starting from 1 Billion as discussed above)
- Number of requests per year =  200 Million per month×12=2.4 Billion
-  lifetime of the sequencer =  total numbers available / yearly requests = 2^ 64 −10 ^9/2.4 Billio =7,686,143,363.63 years


# Coding->
![freecodecamp blog](https://www.freecodecamp.org/news/build-a-scalable-url-shortener-with-distributed-caching-using-redis/?s=0)
![coding challenges](https://codingchallenges.fyi/challenges/challenge-url-shortener)
